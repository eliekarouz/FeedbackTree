In this tutorial, you will learn the steps needed to set up a basic FeedbackTree `Flow`. 
You will build a screen that has a counter and two buttons to increment and decrement the counter.

<div style:"text-align: center;"> 
  <img style: src="https://raw.githubusercontent.com/eliekarouz/FeedbackTree/master/docs/src/orchid/resources/assets/media/counter_app_screenshot.jpeg" width="250"/> 
</div>

<br>

### Getting Started

Let's start by adding FeedbackTree as a dependency to the `build.gradle (app)` file. 

```gro
dependencies {
  implementation "com.github.eliekarouz.feedbacktree:feedbacktree:0.11.1"
}
```

Note that the library is published to `Maven Central`. You might also need to add to your `build.gradle (.)`

```groo
allprojects {
  repositories {
    mavenCentral()
  }
}
```

Although it is a very simple screen, and, we might not use the full power of FeedbackTree, this tutorials provides you a good foundation about FeedbackTree.

### State and Events

*What is a State?*\
A state is the condition your software is in at a specific time. In the context of this tutorial, it is just the value of the counter. \
In Kotlin, states can be represented using `data classes`, `enums`, `sealed classes` or even  `primitive types` . The latter is rarely used in practice.

*What is an Event?*\
It is the external input that will allow the software to transition from one state to another. In the context of this tutorial, you have two events, the user clicked on the increment or decrement buttons.\
In Kotlin, events are usually represented with `sealed classes`

Let's go back to our example, and write the state and events in Kotlin:

```kotlin
data class State(
    val counter: Int
)

sealed class Event {
    object Increment : Event()
    object Decrement : Event()
}
```

Note that we could have just use the `Int` to represent the state but it is really rare in practice to have one primitive type as a state, that's why we will stick with a `data class`.

### Stepper

If you haven't noticed yet, the counter is a `val` and I assume you are wondering how we will update the state when the attributes are immutable. We won't, we will just create a new state!

In FeedbackTree or more generally with state machines, an event "advances" the state machine to a new state. In some cases, the event can cause the state machine to reach an end.  That transformation is called `Stepper` in FeedbackTree.

A stepper is a [pure function](https://en.wikipedia.org/wiki/Pure_function) with the following signature: `(state: State, event: Event) -> Step<State, Output>`.  \
In other terms, the stepper takes the current state your in and the event that occured, and, produces a `Step` which is either the new state we will get in next or the end of state machine/flow.

If we want to write the write the stepper for the Counter tutorial, 

```kotlin
fun stepper(state: State, event: Event): Step<State, Nothing> { // 1
    return when (event) { // 2
        Event.Increment -> state.copy( // 3
            counter = state.counter + 1 
        ).advance() // 4
        Event.Decrement -> state.copy(
            counter = state.counter - 1
        ).advance()
    }
}
```


Let's take a closer look code above:

1. The first generic argument of the `Step` is `State`.
   The second generic argument is  of type `Nothing`. It's the output of the state machine. When it's `Nothing` it means that the state machine cannot complete. 
2. We are using the `copy` feature of `data classes` to create a new state with a different `counter` value.
3. `state.advance()` is a syntactic sugar that converts the new state into a `Step` so that it can be returned to the `Stepper`. 



### What is FeedbackTree ?

FeedbackTree is based on two core concepts a `Flow` and a `Declarative UI`.\
Here's a diagram that shows how FeedbackTree works when applied to the Counter example:

<div style:"text-align: center;"> 
  <img style: src="https://raw.githubusercontent.com/eliekarouz/FeedbackTree/master/docs/src/orchid/resources/assets/media/counter_flow_diagram.svg" width="800"/> 
</div>

<br>

**What is a Flow?**\
A `Flow` kickstarts with some `Input` and produces some `Output`. Although we won't be using the Input/Output concept in this tutorial, it will come handy in future tutorials.\
A `Flow` wraps the state machine: the state, the events, and, the stepper.\
The `Flow` uses `Feedback Loops` to perform network calls, database operations, bluetooth... More on this will come in next tutorials.\
At each state we are in, the Flow will tell what "Screen" we should render on the UI. The screen is a simple data class that will revisit in depth in the next sections.

**The Declarative UI**\
FeedbackTree UI rendering engine takes the "screens" generated by the `Flow` and creates the corresponding `Android.View`. Once the view is created, it will take care of updating it with the new values.

### The Counter Flow

Let's put all the pieces together in a file called **CounterFlow.kt**:

```kotlin
val CounterFlow = Flow<Unit, State, Event, Nothing, CounterScreen>( // 1
    initialState = { State(counter = 0) }, // 2
    stepper = { state, event -> // 3
        when (event) {
            Event.Increment -> state.copy(
                counter = state.counter + 1
            ).advance()
            Event.Decrement -> state.copy(
                counter = state.counter - 1
            ).advance()
        }
    },
    feedbacks = listOf() // 4
    render = { state, context -> // 5
        CounterScreen(state, context.sink)
    }
)

data class State(
    val counter: Int
)

sealed class Event {
    object Increment : Event()
    object Decrement : Event()
}

data class CounterScreen(
    private val state: State,
    val sink: (Event) -> Unit // 6
) {
    val counterText: String = state.counter.toString()
}
```

Here's the breakdown of each component:

1. `CounterFlow` is an immutable variable of type  `Flow`. The `Flow` wraps the different component needed to kickstart the state machine, update it, and render the current state on the UI.
   In the next tutorials, will see that the `Flows` have also another purpose; They take an input and produce an output when they complete.
2. The `initialState` is a function of type `(Input) -> State`. The `Input` in this case is of type `Unit`. Having a dynamic input allows you to start the same flow with different arguments.
3. For small flows, steppers can be written this way but when the flow gets bigger, it's usually preferable to spit them into a separate function. 
4. `feedbacks` are used to perform non-UI side effects, like network calls, database operations, bluetooth..
5. `render` is used to describe what should be displayed on the UI. For instance, this flow will render the `CounterScreen` data class. FeedbackTree will take care of converting that data class into a `android.View` and show it on the UI. The returned "Screens" data class usually hold the properties that we will use to fill/render the UI.
6.  `sink` allows the you to push UI events, like clicks, back to the flow. 

 ### The Counter UI

**Starting the Flow**

**The LayoutBinder**

**ViewRegistry**

### Constraints (counter is always positive) 



